// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: hotel.sql

package db

import (
	"context"
	"database/sql"
)

const createHotel = `-- name: CreateHotel :one
INSERT INTO "Hotel" (
    "Name",
    "Address",
    "City",
    "Rating"
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING "ID", "Name", "Address", "City", "Rating", "Created_At"
`

type CreateHotelParams struct {
	Name    string
	Address string
	City    string
	Rating  sql.NullString
}

func (q *Queries) CreateHotel(ctx context.Context, arg CreateHotelParams) (Hotel, error) {
	row := q.db.QueryRowContext(ctx, createHotel,
		arg.Name,
		arg.Address,
		arg.City,
		arg.Rating,
	)
	var i Hotel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.Rating,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFromHotelID = `-- name: DeleteFromHotelID :exec
DELETE FROM
    "Hotel"
WHERE
    "ID" = $1
`

func (q *Queries) DeleteFromHotelID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteFromHotelID, id)
	return err
}

const findByHotelName = `-- name: FindByHotelName :one
SELECT
    "ID", "Name", "Address", "City", "Rating", "Created_At"
FROM
    "Hotel"
WHERE
    "Name" = $1
LIMIT 1
`

func (q *Queries) FindByHotelName(ctx context.Context, name string) (Hotel, error) {
	row := q.db.QueryRowContext(ctx, findByHotelName, name)
	var i Hotel
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.Rating,
		&i.CreatedAt,
	)
	return i, err
}

const getListHotel = `-- name: GetListHotel :many
SELECT  
    "ID", "Name", "Address", "City", "Rating", "Created_At"
FROM
    "Hotel"
ORDER BY
    "Created_At" DESC
`

func (q *Queries) GetListHotel(ctx context.Context) ([]Hotel, error) {
	rows, err := q.db.QueryContext(ctx, getListHotel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hotel
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.Rating,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListRating = `-- name: GetListRating :many
SELECT
    "ID", "Name", "Address", "City", "Rating", "Created_At"
FROM
    "Hotel"
ORDER BY
    "Rating" DESC
`

func (q *Queries) GetListRating(ctx context.Context) ([]Hotel, error) {
	rows, err := q.db.QueryContext(ctx, getListRating)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hotel
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.Rating,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateByAddress = `-- name: UpdateByAddress :exec
UPDATE
    "Hotel"
SET
    "Address" = $1
WHERE
    "ID" = $2
`

type UpdateByAddressParams struct {
	Address string
	ID      int32
}

func (q *Queries) UpdateByAddress(ctx context.Context, arg UpdateByAddressParams) error {
	_, err := q.db.ExecContext(ctx, updateByAddress, arg.Address, arg.ID)
	return err
}

const updateByName = `-- name: UpdateByName :exec
UPDATE  
    "Hotel"
SET
    "Name" = $1
WHERE
    "ID" = $2
`

type UpdateByNameParams struct {
	Name string
	ID   int32
}

func (q *Queries) UpdateByName(ctx context.Context, arg UpdateByNameParams) error {
	_, err := q.db.ExecContext(ctx, updateByName, arg.Name, arg.ID)
	return err
}

const updateByRating = `-- name: UpdateByRating :exec
UPDATE
    "Hotel"
SET
    "Rating" = $1
WHERE
    "ID" = $2
`

type UpdateByRatingParams struct {
	Rating sql.NullString
	ID     int32
}

func (q *Queries) UpdateByRating(ctx context.Context, arg UpdateByRatingParams) error {
	_, err := q.db.ExecContext(ctx, updateByRating, arg.Rating, arg.ID)
	return err
}
